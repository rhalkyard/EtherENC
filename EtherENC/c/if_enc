/* Ethernet interface logic for EtherENC driver for RISC OS
 *
 * Copyright (C) 2025 Richard Halkyard
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "debug.h"
#include "enc_io.h"
#include "enc_regs.h"
#include "errors.h"
#include "glue.h"
#include "if_enc.h"
#include "iocopy.h"
#include "mbuf.h"
#include "ModuleHdr.h"
#include "os_defs.h"
#include "syslog.h"

#include "kernel.h"
#include "stdlib.h"
#include "string.h"
#include "swis.h"
#include "sys/errno.h"

static void enc_config_read(struct enc_context *ctx)
{
	static const unsigned int default_config = 0;
	unsigned int config;
	int config_valid = 1;

	_swix(OS_Byte, _INR(0, 1) | _OUT(2), OSByte_ReadCMOS, ctx->cmos,
	      &config);

	if ((!config & CONFIG_LINK_MANUAL))
		if ((config & CONFIG_LINK_FULL) || (config & CONFIG_LINK_100))
			config_valid = 0;

	if (config & ~CONFIG_MASK)
		config_valid = 0;

	if (!config_valid) {
		DBGLOG(("EtherENC", 1,
			"Unit %d: Invalid CMOS config, resetting to defaults",
			ctx->dib.dib_unit));
		ctx->config = default_config;
		_swix(OS_Byte, _INR(0, 2), OSByte_WriteCMOS, ctx->cmos,
		      ctx->config);
	} else {
		ctx->config = config;
	}
}

int irqs_off(void)
{
	int s = _kernel_irqs_disabled();
	_kernel_irqs_off();
	DBGLA(*(volatile unsigned int *)0x3340000, DBG_IOFF);
	return s;
}

int irqs_on(void)
{
	int s = _kernel_irqs_disabled();
	_kernel_irqs_on();
	DBGLA(*(volatile unsigned int *)0x3340000, DBG_ION);
	return s;
}

void irq_restore(int s)
{
	if (s) {
		_kernel_irqs_off();
		DBGLA(*(volatile unsigned int *)0x3340000, DBG_IOFF);
	} else {
		_kernel_irqs_on();
		DBGLA(*(volatile unsigned int *)0x3340000, DBG_ION);
	}
}

static void enc_setpage(struct enc_context *ctx, int page)
{
	_swix(Podule_CallLoader, _INR(0, 1) | _IN(3), 0, page, ctx->slot);
}

/* Convert an ENC624J600 address to a pointer into paged MEMC podule space,
 * setting the paging register as appropriate. `addr` should be divisble by 2
 * (i.e. on a halfword boundary). `out_len`, if not NULL, is set to the number
 * of bytes to the end of the page.
 */
static volatile unsigned int *enc_ptr(struct enc_context *ctx,
				      unsigned int addr, unsigned int *out_len)
{
	unsigned int page, off;

	page = addr / ENC_PAGE_LEN;
	off = addr % ENC_PAGE_LEN;

	if (out_len)
		*out_len = ENC_PAGE_LEN - off;

	enc_setpage(ctx, page);
	return &ctx->mem[off / 2];
}

/* Read data from the receive buffer, with wrap-around. `src` is an address in
 * the ENC624J600's memory, between RXBUF_BASE and RXBUF_END.
 */
static unsigned int enc_rx_read(struct enc_context *ctx, int src,
				unsigned char *dest, unsigned short len)
{
	volatile unsigned int *ptr;
	unsigned int pagelen;
	unsigned short this_len;

	while (len) {
		this_len = MIN(len, RXBUF_END - src);
		ptr = enc_ptr(ctx, src, &pagelen);
		this_len = MIN(pagelen, this_len);
		copy_io_in(ptr, dest, this_len);
		len -= this_len;
		dest += this_len;
		src += this_len;
		if (src >= RXBUF_END)
			src = RXBUF_BASE;
	}
	return src;
}

/* Write data to the transmit buffer, with wrap-around. `dest` is an address in
 * the ENC624J600's memory between TXBUF_BASE and TXBUF_END.
 */
static unsigned int enc_tx_write(struct enc_context *ctx, unsigned char *src,
				 int dest, unsigned short len)
{
	volatile unsigned int *ptr;
	unsigned int pagelen;
	unsigned short this_len;

	while (len) {
		this_len = MIN(len, TXBUF_END - dest);
		ptr = enc_ptr(ctx, dest, &pagelen);
		this_len = MIN(pagelen, this_len);
		copy_io_out(src, ptr, this_len);
		len -= this_len;
		src += this_len;
		dest += this_len;
		if (dest >= TXBUF_END)
			dest = TXBUF_BASE;
	}
	return dest;
}

/* Write a value to a PHY register */
static void enc_write_phy_reg(struct enc_context *ctx,
			      const unsigned int phyreg,
			      const unsigned int value)
{
	register volatile unsigned int *regs = ctx->regs;
	/* Wait for internal MII to become available */
	while (ENC_READ_REG(regs, MISTAT) & MISTAT_BUSY) {
	}
	/* MIREGADR must be written with bits 12..8 = 00001 */
	ENC_WRITE_REG(regs, MIREGADR, 0x0100 | phyreg);
	ENC_WRITE_REG(regs, MIWR, value);
	delay_us(26, ctx->rom); /* Operation should take 25.6us */
	/* Wait for write to complete */
	while (ENC_READ_REG(regs, MISTAT) & MISTAT_BUSY) {
	}
}

/* Read a value from a PHY register */
static unsigned int enc_read_phy_reg(struct enc_context *ctx,
				     const unsigned int phyreg)
{
	register volatile unsigned int *regs = ctx->regs;
	/* Wait for internal MII to become available */
	while (ENC_READ_REG(regs, MISTAT) & MISTAT_BUSY) {
	}
	/* MIREGADR must be written with bits 12..8 = 00001 */
	ENC_WRITE_REG(regs, MIREGADR, 0x0100 | phyreg);
	ENC_SET_BITS(regs, MICMD, MICMD_MIIRD);
	delay_us(26, ctx->rom); /* Operation should take 25.6us */
	/* Wait on busy bit just in case */
	while (ENC_READ_REG(regs, MISTAT) & MISTAT_BUSY) {
	}
	ENC_WRITE_REG(regs, MICMD, 0);
	return ENC_READ_REG(regs, MIRD);
}

/* Synchronise driver flags and MAC link parameters to match the PHY, call on
 * init and on every link state change.
 */
static void enc_link_update(struct enc_context *ctx)
{
	register volatile unsigned int *regs = ctx->regs;
	unsigned int estat = ENC_READ_REG(regs, ESTAT);
	unsigned int spddpx =
		(enc_read_phy_reg(ctx, PHSTAT3) & PHSTAT3_SPDDPX_MASK) >>
		PHSTAT3_SPDDPX_SHIFT;
	unsigned int phstat2_plrity = enc_read_phy_reg(ctx, PHSTAT2) &
				      PHSTAT2_PLRITY;
	unsigned int s, flags;
	char *linkstate;
	char *linkspeed;
	char *linkdpx;

	s = irqs_off();
	flags = ctx->flags;
	if (estat & ESTAT_PHYLNK) {
		linkstate = "up";
		flags |= ENC_LINKUP;
	} else {
		if (flags & ENC_LINKUP)
			ctx->stats.base.st_link_failures += 1;
		linkstate = "down";
		flags &= ~ENC_LINKUP;
	}

	switch (spddpx) {
	case 0x6:
		linkspeed = "100";
		linkdpx = "full";
		flags |= ENC_100MB;
		flags |= ENC_FULDPX;
		break;
	case 0x5:
		linkspeed = "10";
		linkdpx = "full";
		flags &= ~ENC_100MB;
		flags |= ENC_FULDPX;
		break;
	case 0x2:
		linkspeed = "100";
		linkdpx = "half";
		flags |= ENC_100MB;
		flags &= ~ENC_FULDPX;
		break;
	case 0x1:
	default:
		linkspeed = "10";
		linkdpx = "half";
		flags &= ~ENC_100MB;
		flags &= ~ENC_FULDPX;
		break;
	}
	ctx->flags = flags;
	irq_restore(s);

	/* Link polarity can only be incorrect on 10mbit */
	if (flags & ENC_100MB)
		ctx->stats.base.st_link_polarity = ST_LINK_POLARITY_CORRECT;
	else
		ctx->stats.base.st_link_polarity =
			phstat2_plrity ? ST_LINK_POLARITY_INCORRECT :
					 ST_LINK_POLARITY_CORRECT;

	/* Wait for flow control state machine to be idle before changing duplex
	 * mode or flow control settings */
	while (!(ENC_READ_REG(regs, ESTAT) & ESTAT_FCIDLE)) {
	};

	if (estat & ESTAT_PHYDPX) {
		/* Full duplex */
		ENC_SET_BITS(regs, MACON2, MACON2_FULDPX);
		ENC_WRITE_REG(regs, MABBIPG, 0x15 << MABBIPG_BBIPG_SHIFT);
		if (ctx->config & CONFIG_FLOW_ON) {
			ENC_SET_BITS(regs, ECON2, ECON2_AUTOFC);
		} else {
			ENC_CLEAR_BITS(regs, ECON2, ECON2_AUTOFC);
			ENC_CLEAR_BITS(regs, ECON1, ECON1_FCOP0 | ECON1_FCOP1);
		}
	} else {
		/* Half duplex */
		ENC_CLEAR_BITS(regs, MACON2, MACON2_FULDPX);
		ENC_WRITE_REG(regs, MABBIPG, 0x12 << MABBIPG_BBIPG_SHIFT);
		/* Disable automatic flow control */
		ENC_CLEAR_BITS(regs, ECON2, ECON2_AUTOFC);
		/* Ensure flow control is deasserted */
		ENC_CLEAR_BITS(regs, ECON1, ECON1_FCOP0 | ECON1_FCOP1);
	}

	DBGLOG(("EtherENC", 1, "Link %s, %smbit %s duplex", linkstate,
		linkspeed, linkdpx));
}

/* Configure PHY link parameters based on CMOS config flags */
static void enc_configure_phy(struct enc_context *ctx)
{
	unsigned int phcon1 = enc_read_phy_reg(ctx, PHCON1);
	unsigned int phana = enc_read_phy_reg(ctx, PHANA);

	if (ctx->config & CONFIG_FLOW_ON) {
		phana &= ~(PHANA_ADPAUS0 | PHANA_ADPAUS1);
		phana |= PHANA_ADPAUS0;
	}

	phcon1 &= ~(PHCON1_ANEN | PHCON1_SPD100 | PHCON1_PFULDPX);
	if (!(ctx->config & CONFIG_LINK_MANUAL)) {
		phcon1 |= PHCON1_ANEN;
	} else {
		phcon1 &= ~(PHCON1_SPD100 | PHCON1_PFULDPX);
		if (ctx->config & CONFIG_LINK_100)
			phcon1 |= PHCON1_SPD100;
		if (ctx->config & CONFIG_LINK_FULL)
			phcon1 |= PHCON1_PFULDPX;
	}

	enc_write_phy_reg(ctx, PHCON1, phcon1);
	enc_write_phy_reg(ctx, PHANA, phana);
	enc_link_update(ctx);
}

static int enc_memtest(struct enc_context *ctx)
{
	register volatile unsigned int *regs = ctx->regs;
	unsigned int i, j, tmp;
	int result = 0;
	const int bufsz = 512;
	const int bufsz_bytes = bufsz * sizeof(unsigned short);
	unsigned short *buf = malloc(bufsz_bytes);
	unsigned char *buf_bytes = (unsigned char *)buf;
	volatile unsigned int *ioptr;

	DBGLA(ctx->rom[0], DBG_MEMTEST_START);
	/* Write own-address pattern to all of RAM */
	for (i = 0; i < ENC_MEM_LEN; i += bufsz_bytes) {
		for (j = 0; j < bufsz_bytes; j += 2) {
			buf[j / 2] = i + j;
		}
		ioptr = enc_ptr(ctx, i, NULL);
		copy_io_out(buf_bytes, ioptr, bufsz_bytes);
	}

	DBGLA(ctx->rom[0], DBG_MEMTEST_START);
	/* Read it back and store it inverted */
	for (i = 0; i < ENC_MEM_LEN; i += bufsz_bytes) {
		ioptr = enc_ptr(ctx, i, NULL);
		copy_io_in(ioptr, buf_bytes, bufsz_bytes);
		for (j = 0; j < bufsz_bytes; j += 2) {
			if (buf[j / 2] != i + j) {
				DBGLA(ctx->rom[0], DBG_MEMTEST_FAIL);
				DBGLA(ctx->rom[1], 1);
				DBGLA(ctx->rom[2], j / 2);
				DBGLA(ctx->rom[3], buf[j / 2]);
				DBGLA(ctx->rom[4], i + j);
				ctx->diag_state = ENC_DIAG_MEMTEST_FAIL;
				ctx->diag_data[0] = 1;
				ctx->diag_data[1] = j / 2;
				ctx->diag_data[2] = buf[j / 2];
				ctx->diag_data[3] = i + j;
				result = -1;
				goto done;
			}
			buf[j / 2] = ~(i + j);
		}
		copy_io_out(buf_bytes, ioptr, bufsz_bytes);
	}
	DBGLA(ctx->rom[0], DBG_MEMTEST_PASS);

	DBGLA(ctx->rom[0], DBG_MEMTEST_START);
	/* Read back inverted values, and store un-inverted */
	for (i = 0; i < ENC_MEM_LEN; i += bufsz_bytes) {
		ioptr = enc_ptr(ctx, i, NULL);
		copy_io_in(ioptr, buf_bytes, bufsz_bytes);
		for (j = 0; j < bufsz_bytes; j += 2) {
			if (buf[j / 2] != (~(i + j) & 0xffff)) {
				DBGLA(ctx->rom[0], DBG_MEMTEST_FAIL);
				DBGLA(ctx->rom[1], 2);
				DBGLA(ctx->rom[2], j / 2);
				DBGLA(ctx->rom[3], buf[j / 2]);
				DBGLA(ctx->rom[4], ~(i + j) & 0xffff);
				ctx->diag_state = ENC_DIAG_MEMTEST_FAIL;
				ctx->diag_data[0] = 2;
				ctx->diag_data[1] = j / 2;
				ctx->diag_data[2] = buf[j / 2];
				ctx->diag_data[3] = ~(i + j) & 0xffff;
				result = -2;
				goto done;
			}
			buf[j / 2] = i + j;
		}
		copy_io_out(buf_bytes, ioptr, bufsz_bytes);
	}
	DBGLA(ctx->rom[0], DBG_MEMTEST_PASS);

	DBGLA(ctx->rom[0], DBG_MEMTEST_START);
	/* Read back again, this time through the registers. */
	ENC_WRITE_REG(regs, EUDAST, 0);
	ENC_WRITE_REG(regs, EUDAND, ENC_MEM_LEN);
	for (i = 0; i < ENC_MEM_LEN; i += bufsz_bytes) {
		ENC_WRITE_REG(regs, EUDARDPT, i);
		tmp = ENC_READ_REG(regs, EUDARDPT);
		if (tmp != i) {
			DBGLA(ctx->rom[0], DBG_MEMTEST_FAIL);
			DBGLA(ctx->rom[1], 3);
			DBGLA(ctx->rom[2], tmp);
			DBGLA(ctx->rom[3], i);
			ctx->diag_state = ENC_DIAG_MEMTEST_FAIL;
			ctx->diag_data[0] = 3;
			ctx->diag_data[1] = tmp;
			ctx->diag_data[2] = i;
			result = -3;
			goto done;
		}
		for (j = 0; j < bufsz_bytes; j++)
			buf_bytes[j] = ENC_READ_REG(regs, EUDADATA) & 0xff;

		for (j = 0; j < bufsz_bytes; j += 2) {
			if (buf[j / 2] != i + j) {
				DBGLA(ctx->rom[0], DBG_MEMTEST_FAIL);
				DBGLA(ctx->rom[1], 4);
				DBGLA(ctx->rom[2], j / 2);
				DBGLA(ctx->rom[3], buf[j / 2]);
				DBGLA(ctx->rom[4], i + j);
				ctx->diag_state = ENC_DIAG_MEMTEST_FAIL;
				ctx->diag_data[0] = 4;
				ctx->diag_data[1] = j / 2;
				ctx->diag_data[2] = buf[j / 2];
				ctx->diag_data[3] = i + j;
				result = -4;
				goto done;
			}
		}
	}
	DBGLA(ctx->rom[0], DBG_MEMTEST_PASS);
	result = 0;
done:
	free(buf);
	enc_setpage(ctx, 0);
	return result;
}

/* Perform startup song-and-dance routine (cf ENC624J600 datasheet, section
 * 8.1), plus the necessary magic accesses that enable power and un-gate IRQs in
 * our glue logic. Returns 0 if initialsation was successful, nonzero if
 * something went wrong.
 */
int enc_poweron(struct enc_context *ctx)
{
	register volatile unsigned int *regs = ctx->regs;
	int val, count;
	/* Count polling-loop iterations as a crude way of tracking timeouts -
	 * each fast-cycle access is 0.5us so 500 iterations is ~250us.
	 */
	const int timeout = 500;

	/* Power chip on */
	_swix(Podule_CallLoader, _IN(0) | _IN(3), ENC_LDR_POWERON, ctx->slot);

	/* Datasheet gives no guidelines as to how long we should wait after
	 * applying power, maybe 100us?
	 */
	delay_us(100, ctx->rom);

	/* Write and readback EUDAST until it responds correctly */
	count = 0;
	do {
		ENC_WRITE_REG(regs, EUDAST, 0x1234);
		val = ENC_READ_REG(regs, EUDAST);
	} while (count++ < timeout && val != 0x1234);
	if (val != 0x1234)
		return -1;

	/* Poll for clock-ready */
	count = 0;
	do {
		val = ENC_READ_REG(regs, ESTAT);
	} while (count++ < timeout && !(val & ESTAT_CLKRDY));

	if (!(val & ESTAT_CLKRDY))
		return -1;

	/* Reset the chip */
	enc_reset(ctx);

	/* EUDAST should have reset to 0 */
	if (ENC_READ_REG(regs, EUDAST) != 0)
		return -1;

	/* Un-gate IRQ */
	_swix(Podule_CallLoader, _IN(0) | _IN(3), ENC_LDR_IRQON, ctx->slot);

	return 0;
}

/* Reset the ENC624J600 */
void enc_reset(struct enc_context *ctx)
{
	int i;
	int s;
	DBGLOG(("EtherENC", 1, "Reset unit %d", ctx->dib.dib_unit));

	if (ctx->regs) {
		s = irqs_off();
		ENC_SET_BITS(ctx->regs, ECON2, ECON2_ETHRST);

		/* Datasheet section 7.2: After setting ETHRST, a delay of 25 μs
		is required before the ENCX24J600 can be accessed again through
		the SPI or PSP interfaces. Additionally, all PHY registers and
		status bits derived from the PHY should not be accessed or used
		for an additional period of 256 μs. */
		delay_us(25 + 256, ctx->rom);

		irq_restore(s);
	}
}

/* Send a packet off the TX queue */
static void enc_start_tx(struct enc_context *ctx)
{
	register volatile unsigned int *regs = ctx->regs;
	struct mbuf *top, *m;
	unsigned int len, econ1, state;
	int s;

	s = irqs_off();
	if (ctx->flags & ENC_TXBUSY) {
		irq_restore(s);
		return;
	}
	IF_DEQUEUE(&ctx->if_snd, top);
	if (!top) {
		irq_restore(s);
		return;
	}
	ctx->flags |= ENC_TXBUSY;
	irq_restore(s);

	DBGLA(ctx->rom[0], DBG_TXSTART);

	len = 0;
	m = top;
	while (m) {
		enc_tx_write(ctx, mtod(m, unsigned char *), TXBUF_BASE + len,
			     m->m_len);
		len += m->m_len;
		m = m->m_next;
	}

	ENC_WRITE_REG(regs, ETXST, TXBUF_BASE);
	ENC_WRITE_REG(regs, ETXLEN, len);
	ENC_SET_BITS(regs, ECON1, ECON1_TXRTS);

	ctx->stats.base.st_tx_frames += 1;
	ctx->stats.base.st_tx_bytes += len;
	m_freem(top);
	DBGLA(ctx->rom[0], DBG_TXDONE);
}

_kernel_oserror *enc_selftest(struct enc_context *ctx)
{
	register volatile unsigned int *regs = ctx->regs;
	_kernel_oserror *err = NULL;
	unsigned int rxen, eie;
	int s;

	/* Disable reception */
	rxen = ENC_READ_REG(regs, ECON1) & ECON1_RXEN;
	ENC_CLEAR_BITS(regs, ECON1, ECON1_RXEN);

	eie = ENC_READ_REG(regs, EIE);
	if ((ctx->flags & ENC_RUNNING) && (eie & EIE_INTIE) &&
	    (eie & EIE_PKTIE))
		while (ENC_READ_REG(regs, ESTAT) & ESTAT_PKTCNT_MASK) {
		}

	s = irqs_off();

	/* Wait for transmitter to be idle */
	while (ENC_READ_REG(regs, ECON1) & ECON1_TXRTS) {
	}

	/* Run the tests (just the one for now) */
	if (enc_memtest(ctx) != 0)
		err = enc_error(ENC_ERR_FAULTY);

	/* Disable user-data pointers */
	ENC_WRITE_REG(regs, EUDAST, 0xffff);
	ENC_WRITE_REG(regs, EUDAND, 0xffff);

	irq_restore(s);

	if (err) {
		enc_shutdown(ctx);
		ctx->stats.base.st_link_status &= ~ST_STATUS_OK;
	} else {
		ENC_SET_BITS(regs, ECON1, rxen);
		ctx->stats.base.st_link_status |= ST_STATUS_OK;
		if (ctx->diag_state == ENC_DIAG_UNKNOWN)
			ctx->diag_state = ENC_DIAG_OK;

		/* Kick the transmitter now that we're back in action */
		if (ctx->flags & ENC_RUNNING)
			enc_start_tx(ctx);
	}

	return err;
}

void enc_get_hwaddr(struct enc_context *ctx, unsigned char *addr)
{
	register volatile unsigned int *regs = ctx->regs;
	unsigned int tmp;
	tmp = ENC_READ_REG(regs, MAADR1);
	addr[0] = tmp & 0xff;
	addr[1] = tmp >> 8;
	tmp = ENC_READ_REG(regs, MAADR2);
	addr[2] = tmp & 0xff;
	addr[3] = tmp >> 8;
	tmp = ENC_READ_REG(regs, MAADR3);
	addr[4] = tmp & 0xff;
	addr[5] = tmp >> 8;
}

/* Try to cleanly shut down the chip */
void enc_shutdown(struct enc_context *ctx)
{
	struct mbuf *m;
	int s = irqs_off();
	ENC_CLEAR_BITS(ctx->regs, ECON1, ECON1_RXEN | ECON1_TXRTS);
	filter_removeall(ctx);
	while (ctx->if_snd.ifq_head) {
		IF_DEQUEUE(&ctx->if_snd, m);
		m_freem(m);
	}
	ctx->flags = 0;
	ctx->stats.base.st_link_status &= ~ST_STATUS_ACTIVE;
	enc_reset(ctx);
	irq_restore(s);
}

/* Set up device context for a given slot */
void enc_attach(struct enc_context *ctx, unsigned int slot)
{
	unsigned int baseaddr;
	_swix(Podule_HardwareAddress, _IN(3) | _OUT(3), slot, &baseaddr);

	ctx->slot = slot;
	ctx->cmos = baseaddr & SLOT_MASK_CMOS;
	ctx->rom = (unsigned int *)(baseaddr & SLOT_MASK_FAST);
	ctx->irq = (unsigned char *)((baseaddr & SLOT_MASK_FAST) + IRQ_REG);
	ctx->regs = (unsigned int *)((baseaddr & SLOT_MASK_FAST) + ENC_REGBASE);
	ctx->mem = (unsigned int *)(baseaddr & SLOT_MASK_MEMC);

	ctx->if_snd.ifq_maxlen = ENC_TXQ_LEN;

	sprintf(ctx->location, "Expansion Slot %d", slot);

	ctx->dib.dib_swibase = EtherENC_00;
	ctx->dib.dib_name = (unsigned char *)ENC_IFNAME;
	ctx->dib.dib_unit = enc_count;
	ctx->dib.dib_address = ctx->hwaddr;
	ctx->dib.dib_module = (unsigned char *)Module_Title;
	ctx->dib.dib_location = ctx->location;
	ctx->dib.dib_slot.sl_slotid = slot;
	ctx->dib.dib_slot.sl_minor = 0;
	ctx->dib.dib_slot.sl_pcmciaslot = 0;
	ctx->dib.dib_slot.sl_mbz = 0;
	ctx->dib.dib_inquire = INQ_MULTICAST | INQ_PROMISCUOUS |
			       INQ_SOFTHWADDR | INQ_HASSTATS;

	enc_config_read(ctx);

	ctx->flags = 0;
	ctx->addresslevel = ADDRLVL_SPECIFIC;
	ctx->errorlevel = ERRLVL_NO_ERRORS;

	memset(&ctx->stats, 0, sizeof(struct enc_stats));
	ctx->stats.base.st_interface_type = ST_TYPE_10BASET;
}

/* Bring up an interface */
_kernel_oserror *enc_init(struct enc_context *ctx)
{
	register volatile unsigned int *regs = ctx->regs;
	unsigned int tmp, rx_tail, flow_hwm, flow_lwm, s;
	_kernel_oserror *err;
	DBGLOG(("EtherENC", 1, "init unit %d", ctx->dib.dib_unit));

	ctx->stats.base.st_link_status |= ST_STATUS_ACTIVE;

	enc_configure_phy(ctx);

	/* Set up RX buffer between end of TX buffer and end of RAM */
	ENC_WRITE_REG(regs, ERXST, RXBUF_BASE);
	rx_tail = RXBUF_END - 2;
	ENC_WRITE_REG(regs, ERXTAIL, rx_tail);
	ctx->rxptr = RXBUF_BASE;

	/* Disable user-data pointers */
	ENC_WRITE_REG(regs, EUDAST, 0xffff);
	ENC_WRITE_REG(regs, EUDAND, 0xffff);

	/* Disable 25MHz clock output */
	ENC_CLEAR_BITS(regs, ECON2, ECON2_COCON_MASK);

	/* Set up Link/Activity LEDs */
	tmp = ENC_READ_REG(regs, EIDLED);
	tmp &= ~(EIDLED_LACFG_MASK | EIDLED_LBCFG_MASK);
	tmp |= (0x2 << EIDLED_LACFG_SHIFT) | /* LED A indicates link state */
	       (0x6 << EIDLED_LBCFG_SHIFT); /* LED B indicates activity */
	ENC_WRITE_REG(regs, EIDLED, tmp);

	/* These flow control parameters are entirely derived out of thin air
	 * and may need revising. Start asserting flow control at 3/4 full, and
	 * deassert flow control at 1/2 full.
	 */
	flow_hwm = (RXBUF_LEN - (RXBUF_LEN / 4)) / 96;
	flow_lwm = (RXBUF_LEN / 2) / 96;
	tmp = (flow_hwm << ERXWM_RXFWM_SHIFT) | (flow_lwm << ERXWM_RXEWM_SHIFT);
	ENC_WRITE_REG(regs, ERXWM, tmp);

	DBGLOG(("EtherENC", 1, "unit %d hwaddr %02x:%02x:%02x:%02x:%02x:%02x",
		ctx->dib.dib_unit, ctx->hwaddr[0], ctx->hwaddr[1],
		ctx->hwaddr[2], ctx->hwaddr[3], ctx->hwaddr[4],
		ctx->hwaddr[5]));

	ENC_SET_BITS(regs, EIE,
		     EIE_INTIE | EIE_LINKIE | EIE_PKTIE | EIE_TXIE |
			     EIE_TXABTIE | EIE_RXABTIE | EIE_PCFULIE);
	s = irqs_off();
	ctx->flags |= ENC_RUNNING;
	irq_restore(s);

	return NULL;
}

/* Entrypoint for transmit SWI */
_kernel_oserror *enc_transmit(int flags, struct enc_context *ctx,
			      unsigned short frame_type, struct mbuf *mb,
			      unsigned char *dest, unsigned char *source)
{
	int s;
	struct ether_header *hdr;
	struct mbuf *top, *tmp = NULL;
	_kernel_oserror *err = NULL;

	if (!(ENC_READ_REG(ctx->regs, ESTAT) & ESTAT_PHYLNK)) {
		err = enc_error(ENETDOWN);
		goto done;
	}

	/* WEIRDNESS ALERT: mb is not just an mbuf chain, but potentially a list
	 * of mbuf chains linked through mb->m_list. Each chain in the list
	 * represents a separate payload to transmit using the same source,
	 * destination, and frame type. This means that in event of an error, we
	 * still have to make sure that *all* chains in the list are handled.
	 */
	while (mb) {
		tmp = mb->m_list;
		top = m_alloc_s(sizeof(struct ether_header), NULL);
		if (!top) {
			err = enc_error(ENOBUFS);
			s = irqs_off();
			ctx->stats.base.st_tx_general_errors += 1;
			ctx->stats.tx_nombufs += 1;
			irq_restore(s);
			DBGLA(ctx->rom[0], DBG_TXERR);
			DBGLA(ctx->rom[1], 0);
			DBGLA(ctx->rom[2], sizeof(struct ether_header));

			if (!(flags & TX_PROTOSDATA))
				m_freem(mb);

			goto done;
		}

		/* Build the ethernet header in a new mbuf */
		hdr = mtod(top, struct ether_header *);
		top->m_len = ETH_HDRLEN;
		memcpy(hdr->ether_dhost, dest, sizeof(struct ether_addr));
		if (flags & TX_FAKESOURCE)
			memcpy(hdr->ether_shost, source,
			       sizeof(struct ether_addr));
		else
			memcpy(hdr->ether_shost, ctx->hwaddr,
			       sizeof(struct ether_addr));
		hdr->ether_type = _HTONS(frame_type);

		/* Make sure that the payload chain is safe to queue (i.e. owned
		 * by us and consisting of safe data).
		 */
		if (flags & TX_PROTOSDATA)
			mb = m_copy(mb, 0, M_COPYALL);
		else
			mb = m_ensure_safe(mb);

		if (!mb) {
			m_free(top);
			err = enc_error(ENOBUFS);
			s = irqs_off();
			ctx->stats.base.st_tx_general_errors += 1;
			ctx->stats.tx_nombufs += 1;
			irq_restore(s);
			DBGLA(ctx->rom[0], DBG_TXERR);
			DBGLA(ctx->rom[1], 1);
			goto done;
		}

		/* Stick the header on top */
		top = m_cat(top, mb);

		/* Queue the packet on the interface. */
		s = irqs_off();
		if (IF_QFULL(&ctx->if_snd)) {
			IF_DROP(&ctx->if_snd);
			irq_restore(s);
			m_freem(top);
			err = enc_error(ENOSPC);
			goto done;
		}
		IF_ENQUEUE(&ctx->if_snd, top);
		if (ctx->if_snd.ifq_len > ctx->stats.tx_hwm)
			ctx->stats.tx_hwm = ctx->if_snd.ifq_len;
		irq_restore(s);
		enc_start_tx(ctx);

		mb = tmp;
	}
done:
	/* Free any remaining mbuf chains */
	mb = tmp;
	while (mb) {
		tmp = mb->m_list;
		m_freem(mb);
		mb = tmp;
	}
	return err;
}

/* Entrypoint for stats SWI */
_kernel_oserror *enc_stats(int flags, struct enc_context *ctx, void *buffer)
{
	int s;
	struct stats *stats = (struct stats *)buffer;
	if (flags & DCIDriverStats_GetStats) {
		s = irqs_off();
		memcpy(buffer, &ctx->stats.base, sizeof(struct stats));
		irq_restore(s);
	} else if (flags & DCIDriverStats_GetENCStats) {
		s = irqs_off();
		memcpy(buffer, &ctx->stats, sizeof(struct enc_stats));
		irq_restore(s);
	} else {
		memset(buffer, 0, sizeof(struct stats));
		stats->st_interface_type = 0xff;
		stats->st_link_status = 0xff;
		stats->st_link_failures = 0xff;
		stats->st_tx_frames = 0xffffffff;
		stats->st_tx_bytes = 0xffffffff;
		stats->st_tx_general_errors = 0xffffffff;
		stats->st_dropped_frames = 0xffffffff;
		stats->st_unwanted_frames = 0xffffffff;
		stats->st_rx_frames = 0xffffffff;
		stats->st_rx_bytes = 0xffffffff;
	}

	return NULL;
}

/* Handle a received packet */
static int enc_rpkt(struct enc_context *ctx)
{
	struct enc_pkthdr hdr;
	struct filter *f;
	struct mbuf *top, *m;
	unsigned short pktlen, rxptr, rxtail, orig_rxptr;
	unsigned int thislen;
	unsigned char *data;
	int err = 0;
	RxHdr *rxh;

	DBGLA(ctx->rom[0], DBG_RXSTART);

	/* Read ENC624J600 header (including ethernet header) */
	rxptr = enc_rx_read(ctx, ctx->rxptr, (unsigned char *)&hdr, ENC_HDRLEN);
	pktlen = hdr.length - ETH_HDRLEN - 4;
	hdr.ether_header.ether_type = _NTOHS(hdr.ether_header.ether_type);

	/* Sanity-check packet length and next-packet pointer. */
	if (pktlen > ETHERMTU || hdr.next >= RXBUF_END ||
	    hdr.next < RXBUF_BASE) {
		err = -1;
		DBGLA(ctx->rom[0], DBG_RXERR);
		DBGLA(ctx->rom[1], ctx->rxptr);
		DBGLA(ctx->rom[2], hdr.next);
		DBGLA(ctx->rom[3], pktlen);
		ctx->diag_state = ENC_DIAG_RX_FAULT;
		ctx->diag_data[0] = ctx->rxptr;
		ctx->diag_data[1] = hdr.next;
		ctx->diag_data[2] = pktlen;
		ctx->stats.base.st_dropped_frames += 1;
		goto errexit;
	}

	f = filter_lookup(ctx, &hdr);
	if (f) {
		/* Only bother to read the payload if a handler is interested in
		 * it */
		top = m_alloc_s(sizeof(RxHdr), NULL);
		if (!top) {
			DBGLOG(("EtherENC", 1,
				"out of mbufs trying to allocate %d bytes",
				sizeof(RxHdr)));

			DBGLA(ctx->rom[0], DBG_RXERR);
			DBGLA(ctx->rom[1], 0);
			DBGLA(ctx->rom[2], sizeof(RxHdr));
			ctx->stats.base.st_dropped_frames += 1;
			ctx->stats.rx_nombufs += 1;
			goto done;
		}

		/* Convert ENC624J600+ethernet headers to DCI header */
		top->m_type = MT_HEADER;
		rxh = mtod(top, RxHdr *);
		memcpy(&rxh->rx_src_addr, &hdr.ether_header.ether_shost, 6);
		memcpy(&rxh->rx_dst_addr, &hdr.ether_header.ether_dhost, 6);
		rxh->rx_frame_type = hdr.ether_header.ether_type;
		rxh->rx_error_level = (hdr.flags & RSV_OK) ? 0 : 1;

		m = m_alloc(pktlen, NULL);
		if (!m) {
			DBGLOG(("EtherENC", 1,
				"out of mbufs trying to allocate %d bytes",
				pktlen));
			DBGLA(ctx->rom[0], DBG_RXERR);
			DBGLA(ctx->rom[1], 1);
			DBGLA(ctx->rom[2], pktlen);
			m_free(top);
			ctx->stats.base.st_dropped_frames += 1;
			ctx->stats.rx_nombufs += 1;
			goto done;
		}
		top = m_cat(top, m);

		m = top;
		while (pktlen) {
			m = m->m_next;
			thislen = MIN(m->m_len, pktlen);
			data = mtod(m, unsigned char *);
			m->m_type = MT_DATA;
			m->m_len = thislen;

			rxptr = enc_rx_read(ctx, rxptr, data, thislen);
			pktlen -= thislen;
		}

		ctx->stats.base.st_rx_frames += 1;
		ctx->stats.base.st_rx_bytes += hdr.length;

		call_handler(&ctx->dib, top, f->handler, f->pw);
	} else {
		ctx->stats.base.st_unwanted_frames += 1;
	}

done:
	ctx->rxptr = hdr.next;
	rxtail = ctx->rxptr - 2;
	if (rxtail < RXBUF_BASE)
		rxtail += RXBUF_LEN;
	ENC_WRITE_REG(ctx->regs, ERXTAIL, rxtail);

errexit:
	/* Always leave the paging register at 0 in case this recieve
	 * interrupted a transmit while it was copying a packet into the TX
	 * buffer.
	 */
	enc_setpage(ctx, 0);
	DBGLA(ctx->rom[0], DBG_RXDONE);
	return err;
}

/* Ethernet interrupts are frequent and potentially time-consuming, but not
 * especially high priority. To avoid unacceptable interrupt latency in the rest
 * of the system, our IRQ handler deasserts our card's IRQ, and then re-enables
 * interrupts while servicing our card, so other hardware can interrupt it.
 */
_kernel_oserror *enc_isr(_kernel_swi_regs *r, void *pw)
{
	/* irq_veneer0 puts the context pointer in r0 for us */
	struct enc_context *ctx = (struct enc_context *)r->r[0];
	register volatile unsigned int *regs = ctx->regs;
	unsigned int eir = ENC_READ_REG(regs, EIR);
	unsigned int pktcnt, i, s, s2;
	DBGIRQ(1);

	ctx->stats.irq_count += 1;
	DBGLA(ctx->rom[0], DBG_IRQENTER);
	ENC_CLEAR_BITS(regs, EIE, EIE_INTIE);
	s = irqs_on();

	if (eir & EIR_LINKIF) {
		/* Link state changed */
		ENC_CLEAR_BITS(regs, EIR, EIR_LINKIF);
		enc_link_update(ctx);
	}

	if (eir & (EIR_TXIF | EIR_TXABTIF)) {
		/* TX completed */
		if (eir & EIR_TXABTIF) {
			ctx->stats.base.st_tx_general_errors += 1;
			DBGLOG(("EtherENC", 1, "TX aborted"));
		}
		ENC_CLEAR_BITS(regs, EIR, EIR_TXIF | EIR_TXABTIF);
		s2 = irqs_off();
		ctx->flags &= ~ENC_TXBUSY;
		irq_restore(s2);
		enc_start_tx(ctx);
	}

	if (eir & (EIR_RXABTIF | EIR_PCFULIF)) {
		/* Log dropped packet */
		ctx->stats.base.st_dropped_frames += 1;
		DBGLOG(("EtherENC", 1, "RX error, packet dropped"));
		ENC_CLEAR_BITS(regs, EIR, EIR_RXABTIF | EIR_PCFULIF);
	}

	if (eir & EIR_PKTIF) {
		/* Receive packet */
		pktcnt = ENC_READ_REG(regs, ESTAT) & ESTAT_PKTCNT_MASK;
		if (pktcnt > ctx->stats.rx_hwm)
			ctx->stats.rx_hwm = pktcnt;
		for (i = 0; i < pktcnt; i++) {
			if (enc_rpkt(ctx) == 0) {
				ENC_SET_BITS(regs, ECON1, ECON1_PKTDEC);
			} else {
				ctx->stats.base.st_link_status &= ~ST_STATUS_OK;
				enc_shutdown(ctx);
				irq_restore(s);
				DBGLA(ctx->rom[0], DBG_IRQLEAVE_ERR);
				DBGIRQ(0);
				return;
			}
		}
	}

	irq_restore(s);
	ENC_SET_BITS(regs, EIE, EIE_INTIE);
	DBGLA(ctx->rom[0], DBG_IRQLEAVE);
	DBGIRQ(0);
}
