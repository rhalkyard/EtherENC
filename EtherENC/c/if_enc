/* Ethernet interface logic for EtherENC driver for RISC OS
 *
 * Copyright (C) 2025 Richard Halkyard
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "debug.h"
#include "enc_io.h"
#include "enc_regs.h"
#include "errors.h"
#include "if_enc.h"
#include "iocopy.h"
#include "mbuf.h"
#include "ModuleHdr.h"
#include "os_defs.h"
#include "syslog.h"

#include "kernel.h"
#include "stdlib.h"
#include "string.h"
#include "swis.h"
#include "sys/errno.h"

static void enc_config_read(struct enc_context *ctx)
{
	static const unsigned int default_config = 0;
	unsigned int config;
	int config_valid = 1;

	_swix(OS_Byte, _INR(0, 1) | _OUT(2), OSByte_ReadCMOS, ctx->cmos,
	      &config);

	if ((!config & CONFIG_LINK_MANUAL))
		if ((config & CONFIG_LINK_FULL) || (config & CONFIG_LINK_100))
			config_valid = 0;

	if (config & ~CONFIG_MASK)
		config_valid = 0;

	if (!config_valid) {
		DBGLOG(("EtherENC", 1,
			"Unit %d: Invalid CMOS config, resetting to defaults",
			ctx->dib.dib_unit));
		ctx->config = default_config;
		_swix(OS_Byte, _INR(0, 2), OSByte_WriteCMOS, ctx->cmos,
		      ctx->config);
	} else {
		ctx->config = config;
	}
}

int irqs_off(void)
{
	int s = _kernel_irqs_disabled();
	_kernel_irqs_off();
	if (!s)
		DBGLA(*(volatile unsigned int *)0x3340000, DBG_IOFF);
	return s;
}

void irq_restore(int s)
{
	if (s) {
		_kernel_irqs_off();
	} else {
		_kernel_irqs_on();
		DBGLA(*(volatile unsigned int *)0x3340000, DBG_ION);
	}
}

static void enc_setpage(struct enc_context *ctx, int page)
{
	_swix(Podule_CallLoader, _INR(0, 1) | _IN(3), 0, page, ctx->slot);
}

/* Convert an ENC624J600 address to a pointer into paged MEMC podule space,
 * setting the paging register as appropriate. `addr` should be divisble by 2
 * (i.e. on a halfword boundary). `out_len`, if not NULL, is set to the number
 * of bytes to the end of the page.
 */
static volatile unsigned int *enc_ptr(struct enc_context *ctx,
				      unsigned int addr, unsigned int *out_len)
{
	unsigned int page, off;

	page = addr / ENC_PAGE_LEN;
	off = addr % ENC_PAGE_LEN;

	if (out_len)
		*out_len = ENC_PAGE_LEN - off;

	enc_setpage(ctx, page);
	return &ctx->mem[off / 2];
}

/* Read data from the receive buffer, with wrap-around. `src` is an address in
 * the ENC624J600's memory, between RXBUF_BASE and RXBUF_END.
 */
static unsigned int enc_rx_read(struct enc_context *ctx, int src,
				unsigned char *dest, unsigned short len)
{
	volatile unsigned int *ptr;
	unsigned int pagelen;
	unsigned short this_len;

	while (len) {
		this_len = MIN(len, RXBUF_END - src);
		ptr = enc_ptr(ctx, src, &pagelen);
		this_len = MIN(pagelen, this_len);
		copy_io_in(ptr, dest, this_len);
		len -= this_len;
		dest += this_len;
		src += this_len;
		if (src >= RXBUF_END)
			src = RXBUF_BASE;
	}
	return src;
}

/* Write data to the transmit buffer, with wrap-around. `dest` is an address in
 * the ENC624J600's memory between TXBUF_BASE and TXBUF_END.
 */
static unsigned int enc_tx_write(struct enc_context *ctx, unsigned char *src,
				 int dest, unsigned short len)
{
	volatile unsigned int *ptr;
	unsigned int pagelen;
	unsigned short this_len;

	while (len) {
		this_len = MIN(len, TXBUF_END - dest);
		ptr = enc_ptr(ctx, dest, &pagelen);
		this_len = MIN(pagelen, this_len);
		copy_io_out(src, ptr, this_len);
		len -= this_len;
		src += this_len;
		dest += this_len;
		if (dest >= TXBUF_END)
			dest = TXBUF_BASE;
	}
	return dest;
}

/* Write a value to a PHY register */
static void enc_write_phy_reg(struct enc_context *ctx,
			      const unsigned int phyreg,
			      const unsigned int value)
{
	/* Wait for internal MII to become available */
	while (ENC_READ_REG(ctx->regs, MISTAT) & MISTAT_BUSY) {
	}
	/* MIREGADR must be written with bits 12..8 = 00001 */
	ENC_WRITE_REG(ctx->regs, MIREGADR, 0x0100 | phyreg);
	ENC_WRITE_REG(ctx->regs, MIWR, value);
	delay_us(26, ctx->rom); /* Operation should take 25.6us */
	/* Wait for write to complete */
	while (ENC_READ_REG(ctx->regs, MISTAT) & MISTAT_BUSY) {
	}
}

/* Read a value from a PHY register */
static unsigned int enc_read_phy_reg(struct enc_context *ctx,
				     const unsigned int phyreg)
{
	/* Wait for internal MII to become available */
	while (ENC_READ_REG(ctx->regs, MISTAT) & MISTAT_BUSY) {
	}
	/* MIREGADR must be written with bits 12..8 = 00001 */
	ENC_WRITE_REG(ctx->regs, MIREGADR, 0x0100 | phyreg);
	ENC_SET_BITS(ctx->regs, MICMD, MICMD_MIIRD);
	delay_us(26, ctx->rom); /* Operation should take 25.6us */
	/* Wait on busy bit just in case */
	while (ENC_READ_REG(ctx->regs, MISTAT) & MISTAT_BUSY) {
	}
	ENC_WRITE_REG(ctx->regs, MICMD, 0);
	return ENC_READ_REG(ctx->regs, MIRD);
}

/* Synchronise driver flags and MAC link parameters to match the PHY, call on
 * init and on every link state change.
 */
static void enc_link_update(struct enc_context *ctx)
{
	unsigned int estat = ENC_READ_REG(ctx->regs, ESTAT);
	unsigned int spddpx =
		(enc_read_phy_reg(ctx, PHSTAT3) & PHSTAT3_SPDDPX_MASK) >>
		PHSTAT3_SPDDPX_SHIFT;
	unsigned int polarity =
		!!(enc_read_phy_reg(ctx, PHSTAT2) & PHSTAT2_PLRITY);
	char *linkstate;
	char *linkspeed;
	char *linkdpx;

	/* Get link state info. */
	if (estat & ESTAT_PHYLNK) {
		linkstate = "up";
		ctx->flags |= ENC_LINKUP;
	} else {
		if (ctx->flags & ENC_LINKUP)
			ctx->stats.base.st_link_failures += 1;
		linkstate = "down";
		ctx->flags &= ~ENC_LINKUP;
	}

	switch (spddpx) {
	case 0x6:
		linkspeed = "100";
		linkdpx = "full";
		ctx->flags |= ENC_100MB;
		ctx->flags |= ENC_FULDPX;
		break;
	case 0x5:
		linkspeed = "10";
		linkdpx = "full";
		ctx->flags &= ~ENC_100MB;
		ctx->flags |= ENC_FULDPX;
		break;
	case 0x2:
		linkspeed = "100";
		linkdpx = "half";
		ctx->flags |= ENC_100MB;
		ctx->flags &= ~ENC_FULDPX;
		break;
	case 0x1:
	default:
		linkspeed = "10";
		linkdpx = "half";
		ctx->flags &= ~ENC_100MB;
		ctx->flags &= ~ENC_FULDPX;
		break;
	}

	ctx->stats.base.st_link_polarity = polarity ? 1 : 0;

	/* Wait for flow control state machine to be idle before changing duplex
	 * mode or flow control settings */
	while (!(ENC_READ_REG(ctx->regs, ESTAT) & ESTAT_FCIDLE)) {
	};

	if (estat & ESTAT_PHYDPX) {
		/* Full duplex */
		ENC_SET_BITS(ctx->regs, MACON2, MACON2_FULDPX);
		ENC_WRITE_REG(ctx->regs, MABBIPG, 0x15 << MABBIPG_BBIPG_SHIFT);
		if (ctx->config & CONFIG_FLOW_ON) {
			ENC_SET_BITS(ctx->regs, ECON2, ECON2_AUTOFC);
		} else {
			ENC_CLEAR_BITS(ctx->regs, ECON2, ECON2_AUTOFC);
			ENC_CLEAR_BITS(ctx->regs, ECON1,
				       ECON1_FCOP0 | ECON1_FCOP1);
		}
	} else {
		/* Half duplex */
		ENC_CLEAR_BITS(ctx->regs, MACON2, MACON2_FULDPX);
		ENC_WRITE_REG(ctx->regs, MABBIPG, 0x12 << MABBIPG_BBIPG_SHIFT);
		/* Disable automatic flow control */
		ENC_CLEAR_BITS(ctx->regs, ECON2, ECON2_AUTOFC);
		/* Ensure flow control is deasserted */
		ENC_CLEAR_BITS(ctx->regs, ECON1, ECON1_FCOP0 | ECON1_FCOP1);
	}

	DBGLOG(("EtherENC", 1, "Link %s, %smbit %s duplex", linkstate,
		linkspeed, linkdpx));
}

/* Configure PHY link parameters based on CMOS config flags */
static void enc_configure_phy(struct enc_context *ctx)
{
	unsigned int phcon1 = enc_read_phy_reg(ctx, PHCON1);
	unsigned int phana = enc_read_phy_reg(ctx, PHANA);

	if (ctx->config & CONFIG_FLOW_ON) {
		phana &= ~(PHANA_ADPAUS0 | PHANA_ADPAUS1);
		phana |= PHANA_ADPAUS0;
	}

	phcon1 &= ~(PHCON1_ANEN | PHCON1_SPD100 | PHCON1_PFULDPX);
	if (!(ctx->config & CONFIG_LINK_MANUAL)) {
		phcon1 |= PHCON1_ANEN;
	} else {
		phcon1 &= ~(PHCON1_SPD100 | PHCON1_PFULDPX);
		if (ctx->config & CONFIG_LINK_100)
			phcon1 |= PHCON1_SPD100;
		if (ctx->config & CONFIG_LINK_FULL)
			phcon1 |= PHCON1_PFULDPX;
	}

	enc_write_phy_reg(ctx, PHCON1, phcon1);
	enc_write_phy_reg(ctx, PHANA, phana);
	enc_link_update(ctx);
}

static int enc_memtest(struct enc_context *ctx)
{
	unsigned int i, j;
	int result = 0;
	const int bufsz = 512;
	const int bufsz_bytes = bufsz * sizeof(unsigned short);
	unsigned short *buf = malloc(bufsz_bytes);
	unsigned char *buf_bytes = (unsigned char *)buf;
	volatile unsigned int *ioptr;

	DBGLA(ctx->rom[0], DBG_MEMTEST_START);
	/* Write own-address pattern to all of RAM */
	for (i = 0; i < ENC_MEM_LEN; i += bufsz_bytes) {
		for (j = 0; j < bufsz_bytes; j += 2) {
			buf[j / 2] = i + j;
		}
		ioptr = enc_ptr(ctx, i, NULL);
		copy_io_out(buf_bytes, ioptr, bufsz_bytes);
	}

	DBGLA(ctx->rom[0], DBG_MEMTEST_START);
	/* Read it back and store it inverted */
	for (i = 0; i < ENC_MEM_LEN; i += bufsz_bytes) {
		ioptr = enc_ptr(ctx, i, NULL);
		copy_io_in(ioptr, buf_bytes, bufsz_bytes);
		for (j = 0; j < bufsz_bytes; j += 2) {
			if (buf[j / 2] != i + j) {
				DBGLA(ctx->rom[0], DBG_MEMTEST_FAIL);
				result = -1;
				goto done;
			}
			buf[j / 2] = ~(i + j);
		}
		copy_io_out(buf_bytes, ioptr, bufsz_bytes);
	}
	DBGLA(ctx->rom[0], DBG_MEMTEST_PASS);

	DBGLA(ctx->rom[0], DBG_MEMTEST_START);
	/* Read back inverted values, and store un-inverted */
	for (i = 0; i < ENC_MEM_LEN; i += bufsz_bytes) {
		ioptr = enc_ptr(ctx, i, NULL);
		copy_io_in(ioptr, buf_bytes, bufsz_bytes);
		for (j = 0; j < bufsz_bytes; j += 2) {
			if (buf[j / 2] != (~(i + j) & 0xffff)) {
				result = -2;
				goto done;
			}
			buf[j / 2] = i + j;
		}
		copy_io_out(buf_bytes, ioptr, bufsz_bytes);
	}
	DBGLA(ctx->rom[0], DBG_MEMTEST_PASS);

	DBGLA(ctx->rom[0], DBG_MEMTEST_START);
	/* Read back again, this time through the registers. */
	ENC_WRITE_REG(ctx->regs, EUDAST, 0);
	ENC_WRITE_REG(ctx->regs, EUDAND, ENC_MEM_LEN);
	for (i = 0; i < ENC_MEM_LEN; i += bufsz_bytes) {
		ENC_WRITE_REG(ctx->regs, EUDARDPT, i);
		for (j = 0; j < bufsz_bytes; j++)
			buf_bytes[j] = ENC_READ_REG(ctx->regs, EUDADATA) & 0xff;

		for (j = 0; j < bufsz_bytes; j += 2) {
			if (buf[j / 2] != i + j) {
				result = -3;
				goto done;
			}
		}
	}
	DBGLA(ctx->rom[0], DBG_MEMTEST_PASS);
	result = 0;
done:
	free(buf);
	enc_setpage(ctx, 0);
	return result;
}

/* Perform startup song-and-dance routine (cf ENC624J600 datasheet, section
 * 8.1), plus the necessary magic accesses that enable power and un-gate IRQs in
 * our glue logic. Returns 0 if initialsation was successful, nonzero if
 * something went wrong.
 */
int enc_poweron(struct enc_context *ctx)
{
	int val, count;
	/* Count polling-loop iterations as a crude way of tracking timeouts -
	 * each fast-cycle access is 0.5us so 500 iterations is ~250us.
	 */
	const int timeout = 500;

	/* Power chip on */
	_swix(Podule_CallLoader, _IN(0) | _IN(3), ENC_LDR_POWERON, ctx->slot);

	/* Datasheet gives no guidelines as to how long we should wait after
	 * applying power, maybe 100us?
	 */
	delay_us(100, ctx->rom);

	/* Write and readback EUDAST until it responds correctly */
	count = 0;
	do {
		ENC_WRITE_REG(ctx->regs, EUDAST, 0x1234);
		val = ENC_READ_REG(ctx->regs, EUDAST);
	} while (count++ < timeout && val != 0x1234);
	if (val != 0x1234)
		return -1;

	/* Poll for clock-ready */
	count = 0;
	do {
		val = ENC_READ_REG(ctx->regs, ESTAT);
	} while (count++ < timeout && !(val & ESTAT_CLKRDY));

	if (!(val & ESTAT_CLKRDY))
		return -1;

	/* Reset the chip */
	enc_reset(ctx);

	/* EUDAST should have reset to 0 */
	if (ENC_READ_REG(ctx->regs, EUDAST) != 0)
		return -1;

	/* Un-gate IRQ */
	_swix(Podule_CallLoader, _IN(0) | _IN(3), ENC_LDR_IRQON, ctx->slot);

	return 0;
}

/* Reset the ENC624J600 */
void enc_reset(struct enc_context *ctx)
{
	int i;
	int s;
	DBGLOG(("EtherENC", 1, "Reset unit %d", ctx->dib.dib_unit));

	if (ctx->regs) {
		s = irqs_off();
		ENC_SET_BITS(ctx->regs, ECON2, ECON2_ETHRST);

		/* Datasheet section 7.2: After setting ETHRST, a delay of 25 μs
		is required before the ENCX24J600 can be accessed again through
		the SPI or PSP interfaces. Additionally, all PHY registers and
		status bits derived from the PHY should not be accessed or used
		for an additional period of 256 μs. */
		delay_us(25 + 256, ctx->rom);

		irq_restore(s);
	}
}

/* Send a packet off the TX queue */
static void enc_start_tx(struct enc_context *ctx)
{
	struct mbuf *top, *m;
	unsigned int len, econ1, state;
	int s;
	DBGLA(ctx->rom[0], DBG_TXSTART);

	if (ENC_READ_REG(ctx->regs, ECON1) & ECON1_TXRTS)
		goto done;

	s = irqs_off();
	IF_DEQUEUE(&ctx->if_snd, top);
	if (!top)
		goto done;

	len = 0;
	m = top;
	while (m) {
		enc_tx_write(ctx, mtod(m, unsigned char *), TXBUF_BASE + len,
			     m->m_len);
		len += m->m_len;
		m = m->m_next;
	}

	ENC_WRITE_REG(ctx->regs, ETXST, TXBUF_BASE);
	ENC_WRITE_REG(ctx->regs, ETXLEN, len);
	ENC_SET_BITS(ctx->regs, ECON1, ECON1_TXRTS);

	ctx->stats.base.st_tx_frames += 1;
	ctx->stats.base.st_tx_bytes += len;
	m_freem(top);
done:
	DBGLA(ctx->rom[0], DBG_TXDONE);
	irq_restore(s);
}

_kernel_oserror *enc_selftest(struct enc_context *ctx)
{
	_kernel_oserror *err = NULL;
	unsigned int rxen, eie;
	int s;

	/* Disable reception */
	rxen = ENC_READ_REG(ctx->regs, ECON1) & ECON1_RXEN;
	ENC_CLEAR_BITS(ctx->regs, ECON1, ECON1_RXEN);

	/* Wait for all received packets to have been processed */
	eie = ENC_READ_REG(ctx->regs, EIE);
	if ((ctx->flags & ENC_RUNNING) && (eie & EIE_INTIE) &&
	    (eie & EIE_PKTIE))
		while (ENC_READ_REG(ctx->regs, ESTAT) & ESTAT_PKTCNT_MASK) {
		}

	s = irqs_off();

	/* Wait for transmitter to be idle */
	while (ENC_READ_REG(ctx->regs, ECON1) & ECON1_TXRTS) {
	}

	/* Run the tests (just the one for now) */
	if (enc_memtest(ctx) != 0)
		err = enc_error(ENC_ERR_FAULTY);

	/* Disable user-data pointers */
	ENC_WRITE_REG(ctx->regs, EUDAST, 0xffff);
	ENC_WRITE_REG(ctx->regs, EUDAND, 0xffff);

	irq_restore(s);

	if (err) {
		enc_shutdown(ctx);
		ctx->stats.base.st_link_status &= ~ST_STATUS_OK;
	} else {
		ENC_SET_BITS(ctx->regs, ECON1, rxen);
		ctx->stats.base.st_link_status |= ST_STATUS_OK;

		/* Kick the transmitter now that we're back in action */
		if (ctx->flags & ENC_RUNNING)
			enc_start_tx(ctx);
	}

	return err;
}

void enc_get_hwaddr(struct enc_context *ctx, unsigned char *addr)
{
	unsigned int tmp;
	tmp = ENC_READ_REG(ctx->regs, MAADR1);
	addr[0] = tmp & 0xff;
	addr[1] = tmp >> 8;
	tmp = ENC_READ_REG(ctx->regs, MAADR2);
	addr[2] = tmp & 0xff;
	addr[3] = tmp >> 8;
	tmp = ENC_READ_REG(ctx->regs, MAADR3);
	addr[4] = tmp & 0xff;
	addr[5] = tmp >> 8;
}

/* Try to cleanly shut down the chip */
void enc_shutdown(struct enc_context *ctx)
{
	struct mbuf *m;
	int s = irqs_off();
	ENC_CLEAR_BITS(ctx->regs, ECON1, ECON1_RXEN | ECON1_TXRTS);
	filter_removeall(ctx);
	while (ctx->if_snd.ifq_head) {
		IF_DEQUEUE(&ctx->if_snd, m);
		m_freem(m);
	}
	ctx->flags &= ~ENC_RUNNING;
	ctx->stats.base.st_link_status &= ~ST_STATUS_ACTIVE;
	enc_reset(ctx);
	irq_restore(s);
}

/* Set up device context for a given slot */
void enc_attach(struct enc_context *ctx, unsigned int slot)
{
	unsigned int baseaddr;
	_swix(Podule_HardwareAddress, _IN(3) | _OUT(3), slot, &baseaddr);

	ctx->slot = slot;
	ctx->cmos = baseaddr & SLOT_MASK_CMOS;
	ctx->rom = (unsigned int *)(baseaddr & SLOT_MASK_FAST);
	ctx->irq = (unsigned char *)((baseaddr & SLOT_MASK_FAST) + IRQ_REG);
	ctx->regs = (unsigned int *)((baseaddr & SLOT_MASK_FAST) + ENC_REGBASE);
	ctx->mem = (unsigned int *)(baseaddr & SLOT_MASK_MEMC);

	ctx->if_snd.ifq_maxlen = IFQ_MAXLEN;

	sprintf(ctx->location, "Expansion Slot %d", slot);

	ctx->dib.dib_swibase = EtherENC_00;
	ctx->dib.dib_name = (unsigned char *)ENC_IFNAME;
	ctx->dib.dib_unit = enc_count;
	ctx->dib.dib_address = ctx->hwaddr;
	ctx->dib.dib_module = (unsigned char *)Module_Title;
	ctx->dib.dib_location = ctx->location;
	ctx->dib.dib_slot.sl_slotid = slot;
	ctx->dib.dib_slot.sl_minor = 0;
	ctx->dib.dib_slot.sl_pcmciaslot = 0;
	ctx->dib.dib_slot.sl_mbz = 0;
	ctx->dib.dib_inquire = INQ_MULTICAST | INQ_PROMISCUOUS |
			       INQ_SOFTHWADDR | INQ_HASSTATS;

	enc_config_read(ctx);
}

/* Bring up an interface */
_kernel_oserror *enc_init(struct enc_context *ctx)
{
	unsigned int tmp, rx_tail, flow_hwm, flow_lwm;
	_kernel_oserror *err;
	DBGLOG(("EtherENC", 1, "init unit %d", ctx->dib.dib_unit));

	ctx->flags = 0;
	ctx->addresslevel = ADDRLVL_SPECIFIC;
	ctx->errorlevel = ERRLVL_NO_ERRORS;

	memset(&ctx->stats, 0, sizeof(struct enc_stats));
	ctx->stats.base.st_interface_type = ST_TYPE_10BASET;

	err = enc_selftest(ctx);
	if (err)
		return err;

	ctx->stats.base.st_link_status |= ST_STATUS_ACTIVE;

	enc_configure_phy(ctx);

	/* Set up RX buffer between end of TX buffer and end of RAM */
	ENC_WRITE_REG(ctx->regs, ERXST, RXBUF_BASE);
	rx_tail = RXBUF_END - 2;
	ENC_WRITE_REG(ctx->regs, ERXTAIL, rx_tail);
	ctx->rxptr = RXBUF_BASE;

	/* Disable user-data pointers */
	ENC_WRITE_REG(ctx->regs, EUDAST, 0xffff);
	ENC_WRITE_REG(ctx->regs, EUDAND, 0xffff);

	/* Disable 25MHz clock output */
	ENC_CLEAR_BITS(ctx->regs, ECON2, ECON2_COCON_MASK);

	/* Set up Link/Activity LEDs */
	tmp = ENC_READ_REG(ctx->regs, EIDLED);
	tmp &= ~(EIDLED_LACFG_MASK | EIDLED_LBCFG_MASK);
	tmp |= (0x2 << EIDLED_LACFG_SHIFT) | /* LED A indicates link state */
	       (0x6 << EIDLED_LBCFG_SHIFT); /* LED B indicates activity */
	ENC_WRITE_REG(ctx->regs, EIDLED, tmp);

	/* These flow control parameters are entirely derived out of thin air
	 * and may need revising. Start asserting flow control at 3/4 full, and
	 * deassert flow control at 1/2 full.
	 */
	flow_hwm = (RXBUF_LEN - (RXBUF_LEN / 4)) / 96;
	flow_lwm = (RXBUF_LEN / 2) / 96;
	tmp = (flow_hwm << ERXWM_RXFWM_SHIFT) | (flow_lwm << ERXWM_RXEWM_SHIFT);
	ENC_WRITE_REG(ctx->regs, ERXWM, tmp);

	DBGLOG(("EtherENC", 1, "unit %d hwaddr %02x:%02x:%02x:%02x:%02x:%02x",
		ctx->dib.dib_unit, ctx->hwaddr[0], ctx->hwaddr[1],
		ctx->hwaddr[2], ctx->hwaddr[3], ctx->hwaddr[4],
		ctx->hwaddr[5]));

	ENC_SET_BITS(ctx->regs, EIE,
		     EIE_INTIE | EIE_LINKIE | EIE_PKTIE | EIE_TXIE |
			     EIE_TXABTIE | EIE_RXABTIE | EIE_PCFULIE);
	ctx->flags |= ENC_RUNNING;

	return NULL;
}

/* Entrypoint for transmit SWI */
_kernel_oserror *enc_transmit(int flags, struct enc_context *ctx,
			      unsigned short frame_type, struct mbuf *mb,
			      unsigned char *dest, unsigned char *source)
{
	int s;
	struct ether_header *hdr;
	struct mbuf *top, *tmp;
	_kernel_oserror *err = NULL;

	if (!(ENC_READ_REG(ctx->regs, ESTAT) & ESTAT_PHYLNK)) {
		err = enc_error(ENETDOWN);
		goto done;
	}

#ifdef TXDEBUG
	DBGLOG(("EtherENC", 1, "Tx packet type=%04x flags-%x", frame_type,
		flags));
	DBGLOG(("EtherENC", 1, "Start of payload:"));
	DBGDATA("EtherENC", 1, mtod(mb, unsigned char *), MIN(mb->m_len, 16),
		0);

	tmp = mb;
	while (tmp->m_next)
		tmp = tmp->m_next;

	DBGLOG(("EtherENC", 1, "End of payload:"));
	DBGDATA("EtherENC", 1, mtod(tmp, unsigned char *), MIN(tmp->m_len, 16),
		tmp->m_len - MIN(tmp->m_len, 16));
#endif

	while (mb) {
		top = m_alloc_s(sizeof(struct ether_header), NULL);
		if (!top) {
			err = enc_error(ENOBUFS);
			goto done;
		}

		/* Build the ethernet header in a new mbuf */
		hdr = mtod(top, struct ether_header *);
		top->m_len = ETH_HDRLEN;
		memcpy(hdr->ether_dhost, dest, sizeof(struct ether_addr));
		if (flags & TX_FAKESOURCE)
			memcpy(hdr->ether_shost, source,
			       sizeof(struct ether_addr));
		else
			memcpy(hdr->ether_shost, ctx->hwaddr,
			       sizeof(struct ether_addr));
		hdr->ether_type = htons(frame_type);

		/* Make sure that the payload chain is safe to queue (i.e. owned
		 * by us and consisting of safe data).
		 */
		if (flags & TX_PROTOSDATA)
			mb = m_copy(mb, 0, M_COPYALL);
		else
			mb = m_ensure_safe(mb);

		if (!mb) {
			err = enc_error(ENOBUFS);
			goto done;
		}
		mb->m_list = NULL;

		top = m_cat(top, mb);

		s = irqs_off();
		if (IF_QFULL(&ctx->if_snd)) {
			IF_DROP(&ctx->if_snd);
			m_freem(top);
		} else {
			IF_ENQUEUE(&ctx->if_snd, top);
			if (ctx->if_snd.ifq_len > ctx->stats.tx_hwm)
				ctx->stats.tx_hwm = ctx->if_snd.ifq_len;
		}
		irq_restore(s);

		mb = mb->m_list;
	}
	enc_start_tx(ctx);
done:
	return err;
}

/* Entrypoint for stats SWI */
_kernel_oserror *enc_stats(int flags, struct enc_context *ctx, void *buffer)
{
	int s;
	struct stats *stats = (struct stats *)buffer;
	if (flags & DCIDriverStats_GetStats) {
		s = irqs_off();
		memcpy(buffer, &ctx->stats.base, sizeof(struct stats));
		irq_restore(s);
	} else if (flags & DCIDriverStats_GetENCStats) {
		s = irqs_off();
		memcpy(buffer, &ctx->stats, sizeof(struct enc_stats));
		irq_restore(s);
	} else {
		memset(buffer, 0, sizeof(struct stats));
		stats->st_interface_type = 0xff;
		stats->st_link_status = 0xff;
		stats->st_link_failures = 0xff;
		stats->st_tx_frames = 0xffffffff;
		stats->st_tx_bytes = 0xffffffff;
		stats->st_tx_general_errors = 0xffffffff;
		stats->st_dropped_frames = 0xffffffff;
		stats->st_unwanted_frames = 0xffffffff;
		stats->st_rx_frames = 0xffffffff;
		stats->st_rx_bytes = 0xffffffff;
	}

	return NULL;
}

/* Handle a received packet */
static void enc_rpkt(struct enc_context *ctx)
{
	struct enc_pkthdr hdr;
	struct filter *f;
	struct mbuf *top, *m;
	unsigned short pktlen, rxptr, rxtail, orig_rxptr;
	unsigned int thislen;
	unsigned char *data;
	RxHdr *rxh;

	DBGLA(ctx->rom[0], DBG_RXSTART);

	/* Read ENC624J600 header (including ethernet header) */
	rxptr = enc_rx_read(ctx, ctx->rxptr, (unsigned char *)&hdr, ENC_HDRLEN);
	pktlen = hdr.length - ETH_HDRLEN;
	hdr.ether_header.ether_type = ntohs(hdr.ether_header.ether_type);

#ifdef RXDEBUG
	DBGLOG(("EtherENC", 1, "rx packet @%x length=%x next=%x rsv=%x type=%x",
		rxptr, hdr.length, hdr.next, hdr.flags,
		hdr.ether_header.ether_type));
#endif
	f = filter_lookup(ctx, &hdr);
	if (f) {
		/* Only bother to read the payload if a handler is interested in
		 * it */
#ifdef RXDEBUG
		DBGLOG(("EtherENC", 1, "got handler %x pw=%x", f->handler,
			f->pw));
#endif
		top = m_alloc_s(sizeof(RxHdr), NULL);
		if (!top) {
			DBGLOG(("EtherENC", 1,
				"out of mbufs trying to allocate %d bytes",
				sizeof(RxHdr)));
			goto done;
		}

		/* Convert ENC624J600+ethernet headers to DCI header */
		top->m_type = MT_HEADER;
		rxh = mtod(top, RxHdr *);
		memcpy(&rxh->rx_src_addr, &hdr.ether_header.ether_shost, 6);
		memcpy(&rxh->rx_dst_addr, &hdr.ether_header.ether_dhost, 6);
		rxh->rx_frame_type = hdr.ether_header.ether_type;
		rxh->rx_error_level = (hdr.flags & RSV_OK) ? 0 : 1;

#ifdef RXDEBUG
		DBGLOG(("EtherENC", 1, "Header:"));
		DBGDATA("EtherENC", 1, rxh, sizeof(RxHdr), 0);
#endif

		m = m_alloc(pktlen, NULL);
		if (!m) {
			DBGLOG(("EtherENC", 1,
				"out of mbufs trying to allocate %d bytes",
				pktlen));
			m_free(top);
			goto done;
		}
		top = m_cat(top, m);

		m = top;
		while (pktlen) {
			m = m->m_next;
			thislen = MIN(m->m_len, pktlen);
			data = mtod(m, unsigned char *);
			m->m_type = MT_DATA;
			m->m_len = thislen;

			rxptr = enc_rx_read(ctx, rxptr, data, thislen);
			pktlen -= thislen;
		}
#ifdef RXDEBUG
		DBGLOG(("EtherENC", 1, "Start of payload:"));
		DBGDATA("EtherENC", 1, mtod(top->m_next, unsigned char *),
			MIN(top->m_next->m_len, 16), 0);

		DBGLOG(("EtherENC", 1, "End of payload:"));
		DBGDATA("EtherENC", 1, mtod(m, unsigned char *),
			MIN(m->m_len, 16), m->m_len - MIN(m->m_len, 16));
#endif

		ctx->stats.base.st_rx_frames += 1;
		ctx->stats.base.st_rx_bytes += hdr.length;

		call_handler(&ctx->dib, top, f->handler, f->pw);
	} else {
		ctx->stats.base.st_unwanted_frames += 1;
	}

done:
	ctx->rxptr = hdr.next;
	rxtail = ctx->rxptr - 2;
	if (rxtail < RXBUF_BASE)
		rxtail += RXBUF_LEN;
	ENC_WRITE_REG(ctx->regs, ERXTAIL, rxtail);

	/* Always leave the paging register at 0 in case this recieve
	 * interrupted a transmit while it was copying a packet into the TX
	 * buffer.
	 */
	enc_setpage(ctx, 0);
	DBGLA(ctx->rom[0], DBG_RXDONE);
}

_kernel_oserror *enc_isr(_kernel_swi_regs *r, void *pw)
{
	/* irq_veneer0 puts the context pointer in r0 for us */
	struct enc_context *ctx = (struct enc_context *)r->r[0];
	unsigned int eir = ENC_READ_REG(ctx->regs, EIR);
	unsigned int pktcnt, i;
	DBGIRQ(1);
#ifdef IRQDEBUG
	DBGLOG(("EtherENC", 1, "Entered ISR"));
#endif
	ctx->stats.irq_count += 1;
	DBGLA(ctx->rom[0], DBG_IRQENTER);

	if (eir & EIR_LINKIF) {
		/* Link state changed */
		ENC_CLEAR_BITS(ctx->regs, EIR, EIR_LINKIF);
		enc_link_update(ctx);
	}

	if (eir & (EIR_TXIF | EIR_TXABTIF)) {
		/* Successful TX */
		if (eir & EIR_TXABTIF) {
			ctx->stats.base.st_tx_general_errors += 1;
			DBGLOG(("EtherENC", 1, "TX aborted"));
		}
		ENC_CLEAR_BITS(ctx->regs, EIR, EIR_TXIF | EIR_TXABTIF);
		enc_start_tx(ctx);
	}

	if (eir & (EIR_RXABTIF | EIR_PCFULIF)) {
		/* Log dropped packet */
		ctx->stats.base.st_dropped_frames += 1;
		DBGLOG(("EtherENC", 1, "RX error, packet dropped"));
		ENC_CLEAR_BITS(ctx->regs, EIR, EIR_RXABTIF | EIR_PCFULIF);
	}

	if (eir & EIR_PKTIF) {
		/* Receive packet */
		pktcnt = ENC_READ_REG(ctx->regs, ESTAT) & ESTAT_PKTCNT_MASK;
		if (pktcnt > ctx->stats.rx_hwm)
			ctx->stats.rx_hwm = pktcnt;
		for (i = 0; i < pktcnt; i++) {
			enc_rpkt(ctx);
			ENC_SET_BITS(ctx->regs, ECON1, ECON1_PKTDEC);
		}
	}
#ifdef IRQDEBUG
	DBGLOG(("EtherENC", 1, "Finished ISR"));
#endif
	DBGLA(ctx->rom[0], DBG_IRQLEAVE);
	DBGIRQ(0);
}
