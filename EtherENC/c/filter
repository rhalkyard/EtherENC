/* Packet-filtering logic for EtherENC driver for RISC OS. Adapted from EtherY
 * driver.
 * 
 * Copyright (c) 2025, Richard Halkyard
 * Copyright (c) 2013, RISC OS Open Ltd
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of RISC OS Open Ltd nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "debug.h"
#include "enc_regs.h"
#include "errors.h"
#include "filter.h"
#include "glue.h"
#include "if_enc.h"

#include "kernel.h"
#include "stdlib.h"
#include "swis.h"
#include "sys/dcistructs.h"
#include "sys/errno.h"

/* Evaluate the current filter chain, configuring the NIC's receive filters to
 * catch the packets we are interested in.
 */
static void filter_eval(struct enc_context *ctx)
{
	struct filter *f;
	int addresslevel = ADDRLVL_SPECIFIC;
	int errorlevel = ERRLVL_NO_ERRORS;
	unsigned int erxfcon, st_rxstatus;

	f = ctx->filters;

	while (f != NULL) {
		if (f->addresslevel > addresslevel)
			addresslevel = f->addresslevel;
		if (f->errorlevel > errorlevel)
			errorlevel = f->errorlevel;
		f = f->next;
	}

	erxfcon = ERXFCON_CRCEN | ERXFCON_RUNTEN;
	if (errorlevel == ERRLVL_ERRORS)
		erxfcon |= ERXFCON_CRCEEN | ERXFCON_RUNTEEN;

	st_rxstatus = 0;
	switch (addresslevel) {
	case ADDRLVL_PROMISCUOUS:
		erxfcon |= ERXFCON_NOTMEEN | ERXFCON_MCEN | ERXFCON_BCEN |
			   ERXFCON_UCEN;
		st_rxstatus = ST_STATUS_PROMISCUOUS;
		break;
	case ADDRLVL_MULTICAST:
		erxfcon |= ERXFCON_MCEN | ERXFCON_BCEN | ERXFCON_UCEN;
		st_rxstatus = ST_STATUS_MULTICAST;
		break;
	case ADDRLVL_NORMAL:
		erxfcon |= ERXFCON_BCEN | ERXFCON_UCEN;
		st_rxstatus = ST_STATUS_BROADCAST;
		break;
	case ADDRLVL_SPECIFIC:
		erxfcon |= ERXFCON_UCEN;
		st_rxstatus = ST_STATUS_DIRECT;
		break;
	}

	ctx->addresslevel = addresslevel;
	ctx->stats.base.st_link_status &= ~ST_STATUS_RXMASK;
	ctx->stats.base.st_link_status |= st_rxstatus;
	ENC_WRITE_REG(ctx->regs, ERXFCON, erxfcon);

	/* Turn off reception if we don't have any filters to consume packets */
	if (ctx->filters)
		ENC_SET_BITS(ctx->regs, ECON1, ECON1_RXEN);
	else
		ENC_CLEAR_BITS(ctx->regs, ECON1, ECON1_RXEN);
}

/* Add a filter to the chain. */
_kernel_oserror *filter_add(struct enc_context *ctx, unsigned int type,
			    unsigned int addrlevel, unsigned int errorlevel,
			    filter_handler_t handler, void *pw)
{
	_kernel_oserror *err = NULL;
	struct filter *f;
	unsigned int framelevel, frametype;
	int s;
	DBGLOG(("EtherENC", 1,
		"add filter type=%x addrlevel=%d errorlevel=%d pw=%x", type,
		addrlevel, errorlevel, pw));

	/* Validate arguments are within range */
	switch (GET_FRAMELEVEL(type)) {
	case FRMLVL_E2SINK:
	case FRMLVL_E2MONITOR:
	case FRMLVL_IEEE:
		if (GET_FRAMETYPE(type) != 0) {
			err = enc_error(EINVAL);
			goto done;
		}
		break;
	case FRMLVL_E2SPECIFIC:
		break;
	default:
		err = enc_error(EINVAL);
		goto done;
	}

	switch (addrlevel) {
	case ADDRLVL_SPECIFIC:
	case ADDRLVL_NORMAL:
	case ADDRLVL_MULTICAST:
	case ADDRLVL_PROMISCUOUS:
		break;
	default:
		err = enc_error(EINVAL);
		goto done;
	}

	switch (errorlevel) {
	case ERRLVL_NO_ERRORS:
	case ERRLVL_ERRORS:
		break;
	default:
		err = enc_error(EINVAL);
		goto done;
	}

	/* Validate that new filter can coexist with existing filters */
	f = ctx->filters;
	while (f) {
		switch (GET_FRAMELEVEL(f->type)) {
		case FRMLVL_E2SPECIFIC:
			if (f->type == type ||
			    GET_FRAMELEVEL(type) == FRMLVL_E2MONITOR) {
				err = enc_error(INETERR_FILTERGONE);
				goto done;
			}
			break;
		case FRMLVL_E2SINK:
			if ((GET_FRAMELEVEL(type) == FRMLVL_E2SINK) ||
			    (GET_FRAMELEVEL(type) == FRMLVL_E2MONITOR)) {
				err = enc_error(INETERR_FILTERGONE);
				goto done;
			}
			break;
		case FRMLVL_E2MONITOR:
			if (GET_FRAMELEVEL(type) != FRMLVL_IEEE) {
				err = enc_error(INETERR_FILTERGONE);
				goto done;
			}
			break;
		case FRMLVL_IEEE:
			if (GET_FRAMELEVEL(type) == FRMLVL_IEEE) {
				err = enc_error(INETERR_FILTERGONE);
				goto done;
			}
			break;
		}
		f = f->next;
	}

	f = malloc(sizeof(struct filter));
	if (!f) {
		err = enc_error(ENOMEM);
		goto done;
	}

	f->type = type;
	f->errorlevel = errorlevel;
	f->addresslevel = addrlevel;
	f->handler = handler;
	f->pw = pw;

	f->next = ctx->filters;
	ctx->filters = f;

	filter_eval(ctx);

	DBGLOG(("EtherENC", 1, "Filter added OK"));
done:
	irq_restore(s);
	return NULL;
}

/* Remove a filter from the chain. */
_kernel_oserror *filter_remove(struct enc_context *ctx, unsigned int type,
			       unsigned int addrlevel, unsigned int errorlevel,
			       filter_handler_t handler, void *pw)
{
	_kernel_oserror *err = NULL;
	struct filter *f, *prev;
	int removed = 0;
	int s;

	DBGLOG(("EtherENC", 1, "remove filter pw=%x", pw));

	prev = NULL;
	s = irqs_off();
	f = ctx->filters;
	while (f) {
		if (f->type == type && f->addresslevel == addrlevel &&
		    f->errorlevel == errorlevel) {
			if (f->handler != handler || f->pw != pw) {
				err = enc_error(EPERM);
				goto done;
			}
			if (prev == NULL)
				ctx->filters = f->next;
			else
				prev->next = f->next;
			removed = 1;
			break;
		}
		prev = f;
		f = f->next;
	}
done:
	irq_restore(s);

	if (removed) {
		_swix(OS_ServiceCall, _INR(0, 4), &ctx->dib,
		      Service_DCIFrameTypeFree, f->type, f->addresslevel,
		      f->errorlevel);
		free(f);
		s = irqs_off();
		filter_eval(ctx);
		irq_restore(s);
		return NULL;
	} else if (!err) {
		err = enc_error(EINVAL);
	}
	return err;
}

/* Remove all filters from the chain belonging to a particular module
 * (identified by module private word)
 */
void filter_removemodule(struct enc_context *ctx, void *pw)
{
	struct filter *f, *tmp;

	f = ctx->filters;
	while (f) {
		tmp = f;
		f = f->next;
		if (tmp->pw == pw)
			filter_remove(ctx, tmp->type, tmp->addresslevel,
				      tmp->errorlevel, tmp->handler, tmp->pw);
	}
}

/* Remove all filters from the chain */
void filter_removeall(struct enc_context *ctx)
{
	struct filter *f, *tmp;

	f = ctx->filters;
	while (f) {
		tmp = f;
		f = f->next;
		filter_remove(ctx, tmp->type, tmp->addresslevel,
			      tmp->errorlevel, tmp->handler, tmp->pw);
	}
}

/* Given a packet header, return the filter that matches it, or NULL if no match
 * found.
 */
struct filter *filter_lookup(struct enc_context *ctx, struct enc_pkthdr *hdr)
{
	struct filter *f, *result, *sink;
	unsigned char class, defects;
	int s;

	if (hdr->flags & RSV_MULTICAST) {
		class = IS_MULTICAST;
	} else if (hdr->flags & RSV_BROADCAST) {
		class = IS_BROADCAST;
	} else if (hdr->flags & RSV_UNICAST) {
		class = IS_MINE;
	} else {
		class = IS_SPECIFIC;
	}

	defects = (hdr->flags & RSV_OK) ? 0 : 1;

	sink = NULL;
	result = NULL;

	s = irqs_off();
	f = ctx->filters;
	while (f) {
		switch (GET_FRAMELEVEL(f->type)) {
		case FRMLVL_E2SINK:
			sink = f;
			break;
		case FRMLVL_E2MONITOR:
			if (hdr->ether_header.ether_type > ETHERMTU &&
			    IS_A_KEEPER(f->addresslevel, class) &&
			    IS_GOOD_ENOUGH(f->errorlevel, defects))
				result = f;
			break;
		case FRMLVL_IEEE:
			if (hdr->ether_header.ether_type <= ETHERMTU &&
			    IS_A_KEEPER(f->addresslevel, class) &&
			    IS_GOOD_ENOUGH(f->errorlevel, defects))
				result = f;
			break;
		case FRMLVL_E2SPECIFIC:
			if (IS_A_KEEPER(f->addresslevel, class) &&
			    IS_GOOD_ENOUGH(f->errorlevel, defects) &&
			    GET_FRAMETYPE(f->type) ==
				    hdr->ether_header.ether_type)
				result = f;
			break;
		}
		if (result)
			break;
		f = f->next;
	}

	if (!result && sink && IS_A_KEEPER(sink->addresslevel, class) &&
	    IS_GOOD_ENOUGH(sink->errorlevel, defects))
		result = sink;

	irq_restore(s);
	return result;
}
