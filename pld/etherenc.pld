Name     EtherENC ;
PartNo   00 ;
Date     6/18/2024 ;
Revision 01 ;
Designer Richard Halkyard ;
Company  - ;
Assembly None ;
Location  ;
Device   f1502isptqfp44 ;

/* Enable JTAG interface with internal 10K pullups on TDI and TMS */
PROPERTY ATMEL { JTAG = ON } ;
PROPERTY ATMEL { TDI_PULLUP = ON } ;
PROPERTY ATMEL { TMS_PULLUP = ON } ;

/* Consider pin assignments to be immutable; don't try to rearrange the design
if it does not fit with the given pin assignments */
PROPERTY ATMEL { PREASSIGN = KEEP } ;

/* Declare control-line outputs as open-collector so we don't have to mess
around with .OE */
PROPERTY ATMEL { OPEN_COLLECTOR = PIRQ, BL, IOGT } ;

/*
OVERVIEW

This CPLD provides basic control logic for IOC and MEMC podule accesses

Signals in ALL CAPS are external I/Os, signals in lowercase are internal nodes.

IOC-space memory map is as follows:

    0000-1FFF   ROM
    2000-23FF   Write: paging latch
                Read: interrupt status
    2400-37FF   Reserved for IDE hardware
    3800-3FFF   ENC624J600 registers

MEMC space provides paged access to the ENC624J600's full address space.
*/

/* INPUT PINS */
PIN 3   = !IORQ ;       /* Handshake request for MEMC accesses */
PIN 6   = !PS ;         /* Podule select for IOC accesses */
PIN 10  = !IORD ;       /* Read strobe (IOC accesses only) */
PIN 11  = !IOWR ;       /* Write strobe (IOC accesses only) */
PIN 12  = RW ;          /* Read/Write */
PIN 13  = !MS ;         /* Podule select for MEMC accesses */
PIN 23  = !ETH_INT ;    /* Interrupt input from ENC624J600 */

PIN [19,18,15,14] = [LA13..10] ;    /* Address lines */

/* SPECIAL INPUTS */
PIN 37  = REF8M ;       /* GCLK1 = 8MHz system reference clock */
PIN 39  = !RST ;        /* GCLR = System reset */

/* OUTPUT PINS */
PIN 2   = !BL ;         /* Buffer latch control for MEMC accesses */
PIN 5   = !IOGT ;       /* Handshake grant for MEMC accesses */
PIN 8   = !PIRQ ;       /* Open-collector IRQ output */
PIN 20  = !ETH_PAGED ;  /* Addressing mode select */
PIN 21  = ETH_RD ;      /* Read strobe for ENC624J600 */
PIN 22  = ETH_WR ;      /* Write strobe for ENC624J600 */
PIN 25  = LATCH_WR ;    /* Write strobe for paging latch */
PIN 27  = !ROM_CS ;     /* Chip select for flash ROM */
PIN 28  = !ROM_RD ;     /* Read strobe for flash ROM */
PIN 30  = !ROM_WR ;     /* Write strobe for flash ROM */
PIN 42  = ETH_PWR ;     /* 3.3V regulator enable */ 

/* DATA PINS */
PIN 43 = D0 ;
PIN 44 = D1 ;

/*
RESERVED
PIN 1   = TDI ;
PIN 7   = TMS ;
PIN 26  = TCK ;
PIN 32  = TDO ;

PIN 9   = VCC ;
PIN 17  = VCC ;
PIN 29  = VCC ;
PIN 41  = VCC ;

PIN 4   = GND ;
PIN 16  = GND ;
PIN 24  = GND ;
PIN 36  = GND ;
*/

/* INTERNAL NODES */
NODE interrupt_enable ;
NODE power_enable ;
NODE memc_cycle ;
NODE memc_late ;

/*
Inhibit power to the ENC624J600 from reset until the first access to its
registers in IOC space. This is a workaround for its lack of hardware reset pin.
Software must discard the result of this first access, and perform the power-on
reset procedure described in Section 8.1 of the datasheet in order to determine
when the chip is ready.

This is not used currently, but intended for a future revision and included here
for testing purposes.
*/
power_enable.AR = RST ;
power_enable.D = 'b'1 ;
power_enable.CK = sel_eth ;
ETH_PWR     = power_enable ;

/*
Disable interrupts from reset until we have seen a read to MEMC space. If the
lack of a hardware reset pin isn't bad enough, the ENC624J600's interupt output
does double duty as a configuration strapping pin, which will cause it to assert
a spuriuos interrupt until the chip is initialised and driving the interrupt
line. ARGH.
*/
interrupt_enable.AR = RST ;
interrupt_enable.D = 'b'1 ;
interrupt_enable.CK = memc_cycle ;
PIRQ        = ETH_INT & interrupt_enable ;

/* Chip-selects for IOC accesses */
sel_rom     = PS & !LA13 ;                          /* 0000-1FFF : ROM */
sel_latch   = PS &  LA13 & !LA12 & !LA11 & !LA10 ;  /* 2000-23FF : Paging latch */
sel_ide1    = PS &  LA13 & !LA12 & !LA11 &  LA10 ;  /* 2400-27FF : IDE (8 bit registers) */
sel_ide2    = PS &  LA13 & !LA12 &  LA11 ;          /* 2800-2FFF : IDE (8 bit high byte) */
sel_ide3    = PS &  LA13 &  LA12 & !LA11 ;          /* 3000-37FF : IDE (16 bit) */
sel_eth     = PS &  LA13 &  LA12 &  LA11 ;          /* 3800-3FFF : Ethernet */

sel_ide     = sel_ide1 # sel_ide2 # sel_ide2 ;

/* Control signals for flash ROM */
ROM_CS      = 'b'1 ;             /* not actually needed */
ROM_RD      = sel_rom & IORD ;
ROM_WR      = sel_rom & IOWR ;

/* Paging/IRQ register writes go to the paging latch */
LATCH_WR    = sel_latch & IOWR ;

/* ... and we respond to reads with our internal IRQ bit */
irq_rd      = sel_latch & IORD ;

/* Control signals for ENC624J600 (APPENDed for MEMC accesses below) */
ETH_RD      = sel_eth & IORD;
ETH_WR      = sel_eth & IOWR ;

/*
Expose interrupt status on read of paging register.

0 = no interrupt, 1 = interrupt

D0     = ENC624J600 asserting interrupt
D1     = reserved for IDE interrupts
D2..D7 = undefined
*/
[D0..D1].oe = irq_rd ;
D0          = PIRQ & ETH_INT ;
D1          = 'b'0 ;

/*
We support two addressing modes for the ENC624J600 - register-only mode,
addressed with LA2..9, and paged mode, addressed with LA2..13 and bits 6..7 of
the patching latch. Register-only mode is used for IOC accesses to registers via
3800-3FFF. Paged mode is used for MEMC accesses to allow direct (and faster)
access to the full 32K of ENC624J600 address space. The ETH_PAGED output drives
a buffer that selects between these modes.

We make our 'default' state paged mode, to gives us as much time as possible for
address setup on a MEMC access.
*/
ETH_PAGED   = !PS ;

/*
Control logic for MEMC accesses.

There are some subtleties here - early ARM is truly RISC-y when it comes to its
bus interface, and talking to it correctly without mediation from IOC is not as
straightforward as, say the 68K or x86. Read the Acorn Enhanced Expansion Card
Specification,
(https://www.chiark.greenend.org.uk/~theom/riscos/docs/expspec.pdf), and chapter
4 of the 1990 ARM databook
(https://bitsavers.org/pdf/acorn/VTI_ARM_Databook_1990.pdf) for background.

TL;DR, there are five key signals:

    /MS     - MEMC access select for this Podule
    /IORQ   - MEMC IO handshake request
    /IOGT   - MEMC IO handshake grant
    /BL     - Data latch control
    REF8M   - 8MHz MEMC reference clock 

From our perspective, a MEMC access starts with /IORQ and /MS being asserted
while REF8M is high. Acorn's documentation explictly states that this can be
used to trigger the start of the cycle asynchronously, without waiting for a
falling REF8M. On the next rising edge of REF8M, MEMC samples /IOGT. If /IOGT is
asserted, then the cycle ends on the falling edge of REF8M. Otherwise, MEMC
stops the ARM clock and samples /IOGT on each rising REF8M until this condition
is met. So far, this is more or less the same as the 68000's /DTACK handshake.
However, MEMC allows DMA and DRAM refresh to occur during I/O wait states, and
it is incumbent on I/O devices to handle the implications of this. For regular
Podule accesses, IOC takes care of this behind the scenes, but when accessing a
Podule directly through MEMC, it's up to us.

During a MEMC access cycle, a DMA 'break' is signalled by MEMC deasserting /IORQ
while REF8M is high. This will only happen in a wait state - i.e. /IOGT was not
asserted when REF8M went high. We may still assert /IOGT at any point, but MEMC
will ignore it until it reasserts /IORQ (which will occur while REF8M is low).
DMA may last up to 15 REF8M periods (1875 ns).

To prevent DMA from interfering with the data lines to our card, we must also
control the latches between the I/O data bus and the processor, using /BL. On
writes, we assert /BL on the rising edge of REF8M following assertion of /MS and
/IORQ, to latch the data from the CPU until it has been read by our device. On
reads we assert /BL when our device is ready, and keep asserting it until the
end of the cycle. /BL must be released within 100ns of REF8M going low at the
end of the cycle.

It should also be noted that while /MS remains asserted through a DMA
interruption, it also remains asserted between sequential accesses (e.g. LDM/STM
instructions), and so cannot be used to identify the bounds of a MEMC cycle. It
must only be used as a qualifier for /IORQ, and the cycle state must be
maintained by the device being accessed.

The advantage of going to all this effort is that timing is not restricted to
IOC's four presets, and can in fact be faster (250 ns) than an IOC 'fast' cycle
(500 ns). Additionally, IOC and MEMC accesses to the same Podule can be treated
as independent address spaces, doubling the rather limited amount of address
space available to a single Podule. The ENC624J600 is fast enough for 250ns
operation (so long as we start the access asynchronously), and we use the MEMC
address space for direct access to packet buffer RAM.

Much simpler logic could be used in this case, since in a 250 ns access there is
no opportunity for DMA to interrupt us. However the logic below aims to be
generalisable to allow wait states, while remaining strictly correct wrt.
Acorn's timing specs.

Note that the full MEMC cycle is represented by the logical-OR of the
`memc_cycle` and `memc_late` flipflops - `memc_cycle` goes to 1 asynchronously
at the start of the cycle (/MS and /IORQ asserted while REF8M is high), and goes
to 0 when the cycle-end condition is met (/IOGT and /IORQ on a rising REF8M).
`memc_late` goes to 1 when the device is ready for an access, and only goes to 0
at the true end of the cycle (the falling REF8M after the end condition). This
is necessary, because on read accesses, /BL must be held until the very end of
the cycle.
*/
memc_early    = !memc_cycle & !memc_late & MS & IORQ & REF8M;

memc_cycle.AR = RST ;
memc_cycle.AP = memc_early ; /* start cycle asynchronously */
memc_cycle.CK = REF8M ;
memc_cycle.D  = memc_cycle & !(IOGT & IORQ) ;

/*
Assert /IOGT on first falling REF8M. For slower devices, `memc_late.D` could be
derived from a handshake signal coming from the device, or by counting an
appropriate number of REF8M cycles.
*/
memc_late.AR  = RST ;
memc_late.CK  = !REF8M ;
memc_late.D   = memc_cycle ;
IOGT          = memc_late & memc_cycle ;

/*
Read: Latch data when device is ready, hold to true end of cycle
Write: Latch data at start of cycle, hold until device has consumed data
*/
BL            = RW & memc_late & !memc_cycle # !RW & memc_cycle ;

/*
Add MEMC access conditions to ENC624J600 read and write strobes. Use
`memc_late` term to extend read strobe so that /BL setup time is OK.
*/
APPEND ETH_WR = memc_cycle & !RW ;
APPEND ETH_RD = (memc_cycle # memc_late) & RW ;
